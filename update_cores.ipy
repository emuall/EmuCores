import os
import pathlib

# Uncomment the cores that require an update
cores = [
    "stella",
    "fceumm",
    "snes9x",
    "genesis_plus_gx",
    "gambatte",
    "melonds",
    "mgba",
    "mupen64plus_next_gles3",
    "fbneo",
    "desmume",
    "prosystem",
    "handy",
    "mednafen_pce_fast",
    "dosbox_pure",
    "mednafen_ngp",
    "mednafen_wswan",
    "mednafen_saturn",
    "picodrive",
    "mame2000",
    "mame2003",
    "mame2003_plus",
    "mame2010",
    "mamearcade",
    "ppsspp",
#    "ppsspp_12",
#    "ppsspp_13",
#    "ppsspp_14",
#    "ppsspp_15",
#    "ppsspp_16",
     "dolphin",
    "citra",
#     "mame4droid",
    "play",
    "yabause",
    "yabasanshiro",
    "mednafen_psx_hw",
    "mednafen_psx",
    "swanstation",
    "pcsx_rearmed",
    "parallel_n64",
    "flycast"
]

archs = ["armeabi-v7a", "arm64-v8a", "x86", "x86_64"]

delivery_install = "<dist:install-time/>"

delivery_on_demand = """
<dist:on-demand />
<dist:install-time>
    <dist:conditions>
        <dist:device-feature dist:name="android.software.leanback"/>
    </dist:conditions>
</dist:install-time>
"""

manifest_content = """
<manifest xmlns:dist="http://schemas.android.com/apk/distribution"
    xmlns:android="http://schemas.android.com/apk/res/android">

    <application
        android:hasCode="false"
        android:extractNativeLibs="true" />

    <dist:module dist:title="@string/core_name_%s">
        <dist:delivery>
            %s
        </dist:delivery>
        <dist:fusing dist:include="true" />
    </dist:module>
</manifest>
"""

gradle_content = """
plugins {
    id("com.android.dynamic-feature")
    id("kotlin-android")
    id("kotlin-kapt")
}

android {
    namespace = "top.aio51.play.core.%s"
    defaultConfig {
        missingDimensionStrategy("cores", "google")
        missingDimensionStrategy("opensource", getSource())
    }
    packaging {
        jniLibs{
            keepDebugSymbols.add("*/*/*_libretro_android.so")
        }
    }
}

dependencies {
    implementation(project(":app"))
    implementation(kotlin(deps.libs.kotlin.stdlib))
}

fun getSource(): String {
    println("Dynamic features: " + gradle.startParameter.taskRequests.toString())
    val source = gradle.startParameter.taskRequests[0].args[0].replace(":app:assemble","").replace(":app:bundle","").replace("assemble","").replace("bundle","").replace("Google","").replace("Git","").replace("Debug","").replace("Release","").lowercase()
    return source.toString()
}

"""

def write_file(chunks, content):
    pathlib.Path(os.path.join(*chunks[:-1])).mkdir(parents=True, exist_ok=True)
    gradle_file = open(os.path.join(*chunks), "w")
    gradle_file.write(content)
    gradle_file.close()

for core_name in cores:
    #! rm -r $core_folder
    core = core_name + "_libretro_android.so.zip"
    so_name = core.replace(".zip", "")
    core_folder = "core_" + core_name

    install_time = delivery_on_demand

    write_file([core_folder, "build.gradle.kts"], gradle_content % (core_name))
    write_file([core_folder, "src", "main", "AndroidManifest.xml"], manifest_content % (core_name, install_time))

    for arch in archs:
        ! wget https://buildbot.libretro.com/nightly/android/latest/$arch/$core -P $core_folder/src/main/jniLibs/$arch
        ! unzip $core_folder/src/main/jniLibs/$arch/$core -d $core_folder/src/main/jniLibs/$arch
        ! rm $core_folder/src/main/jniLibs/$arch/$core
        ! mv $core_folder/src/main/jniLibs/$arch/$so_name $core_folder/src/main/jniLibs/$arch/lib$so_name
        ! rm -f bundled-cores/src/main/jniLibs/$arch/lib$so_name



        #! ln -s ../../../../../$core_folder/src/main/jniLibs/$arch/lib$so_name bundled-cores/src/main/jniLibs/$arch/lib$so_name

